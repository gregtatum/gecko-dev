

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Writing efficient React code &mdash; Firefox Source Docs  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/custom_theme.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../_static/firefox.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.4.4/mermaid.min.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Automated tests" href="../tests/README.html" />
    <link rel="prev" title="Writing efficient code" href="performance.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> Firefox Source Docs
          

          
            
            <img src="../../_static/firefox-wordmark.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../setup/index.html">Getting Set Up To Work On The Firefox Codebase</a></li>
</ul>
<p class="caption"><span class="caption-text">Working On Firefox</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../contributing/index.html">Working on Firefox</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bug-mgmt/index.html">Bug Handling</a></li>
</ul>
<p class="caption"><span class="caption-text">Source Code Documentation</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../browser/index.html">Firefox</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dom/index.html">DOM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../layout/index.html">Layout &amp; CSS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gfx/index.html">Graphics</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Firefox DevTools Contributor Docs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../index.html#getting-started">Getting Started</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html#contributing">Contributing</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../contributing.html">Contributing</a></li>
<li class="toctree-l3"><a class="reference internal" href="find-bugs.html">Find bugs to work on</a></li>
<li class="toctree-l3"><a class="reference internal" href="fixing-bugs.html">How to fix a bug</a></li>
<li class="toctree-l3"><a class="reference internal" href="code-reviews.html">Code reviews</a></li>
<li class="toctree-l3"><a class="reference internal" href="landing-code.html">Landing code</a></li>
<li class="toctree-l3"><a class="reference internal" href="levelling-up.html">Leveling up</a></li>
<li class="toctree-l3"><a class="reference internal" href="coding-standards.html">Coding standards</a></li>
<li class="toctree-l3"><a class="reference internal" href="filing-good-bugs.html">Filing good bugs</a></li>
<li class="toctree-l3"><a class="reference internal" href="performance.html">Investigating performance issues</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Writing efficient React code</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tl-dr-tips">TL;DR tips</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-react-renders-normal-components">How React renders normal components</a></li>
<li class="toctree-l4"><a class="reference internal" href="#shouldcomponentupdate-and-purecomponent-avoiding-renders-altogether"><code class="docutils literal notranslate"><span class="pre">shouldComponentUpdate</span></code> and <code class="docutils literal notranslate"><span class="pre">PureComponent</span></code>: avoiding renders altogether</a></li>
<li class="toctree-l4"><a class="reference internal" href="#diagnosing-performance-issues-with-some-tooling">Diagnosing performance issues with some tooling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#breaking-the-rules-always-measure-first">Breaking the rules: always measure first</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#automated-tests">Automated tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#files-and-directories">Files and directories</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#tool-architectures">Tool Architectures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#frontend">Frontend</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#backend">Backend</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#preferences">Preferences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#about-this-documentation">About this documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../toolkit/index.html">Toolkit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../js/index.html">SpiderMonkey</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mobile/android/geckoview/index.html">Welcome to GeckoView’s documentation!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dom/bindings/webidl/index.html">WebIDL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/libpref/index.html">libpref</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../remote/index.html">Remote Protocol</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../services/common/services/index.html">Services</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../uriloader/index.html">File Handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../widget/cocoa/index.html">Firefox on macOS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../code-quality/index.html">Code quality</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../writing-rust-code/index.html">Writing Rust Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/profiler/index.html">Gecko Profiler</a></li>
</ul>
<p class="caption"><span class="caption-text">The Firefox Build System</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../mach/index.html">Mach</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/try/index.html">Try Server</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../build/buildsystem/index.html">Build System</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../taskcluster/index.html">TaskCluster Task-Graph Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/moztreedocs/index.html">Managing Documentation</a></li>
</ul>
<p class="caption"><span class="caption-text">Testing &amp; Test Infrastructure</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../testing/testing-policy/index.html">Testing Policy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../testing/marionette/index.html">Marionette</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../testing/geckodriver/index.html">geckodriver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web-platform/index.html">web-platform-tests documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/fuzzing/index.html">Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/sanitizer/index.html">Sanitizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../testing/perfdocs/index.html">Performance Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/code-coverage/index.html">Code coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../testing-rust-code/index.html">Testing &amp; Debugging Rust Code</a></li>
</ul>
<p class="caption"><span class="caption-text">Localization &amp; Internationalization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../intl/index.html">Internationalization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../l10n/index.html">Localization</a></li>
</ul>
<p class="caption"><span class="caption-text">Firefox and Python</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../mozbase/index.html">mozbase</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python/index.html">Using third-party Python packages</a></li>
</ul>
<p class="caption"><span class="caption-text">Metrics Collected in Firefox</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../metrics/index.html">Metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../metrics/index.html#pings">Pings</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Firefox Source Docs</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Firefox DevTools Contributor Docs</a> &raquo;</li>
        
      <li>Writing efficient React code</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/devtools/contributing/react-performance-tips.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="writing-efficient-react-code">
<h1>Writing efficient React code<a class="headerlink" href="#writing-efficient-react-code" title="Permalink to this headline">¶</a></h1>
<p>In this article we’ll discuss about the various component types we can use, as
well as discuss some tips to make your React application faster.</p>
<div class="section" id="tl-dr-tips">
<h2>TL;DR tips<a class="headerlink" href="#tl-dr-tips" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Prefer props and state immutability and use <code class="docutils literal notranslate"><span class="pre">PureComponent</span></code> components as a default</p></li>
<li><p>As a convention, the object reference should change <strong>if and only if</strong> the inner data
changes.</p>
<ul>
<li><p>Be careful to never use new instance of functions as props to a Component (it’s fine to use
them as props to a DOM element).</p></li>
<li><p>Be careful to not update a reference if the inner data doesn’t change.</p></li>
</ul>
</li>
<li><p><a class="reference internal" href="performance.html"><span class="doc">Always measure before optimizing</span></a> to have a real impact on
performance. And always measure <em>after</em> optimizing too, to prove your change
had a real impact.</p></li>
</ul>
</div>
<div class="section" id="how-react-renders-normal-components">
<h2>How React renders normal components<a class="headerlink" href="#how-react-renders-normal-components" title="Permalink to this headline">¶</a></h2>
<div class="section" id="what-s-a-normal-component">
<h3>What’s a normal component?<a class="headerlink" href="#what-s-a-normal-component" title="Permalink to this headline">¶</a></h3>
<p>As a start let’s discuss about how React renders normal plain components, that
don’t use <code class="docutils literal notranslate"><span class="pre">shouldComponentUpdate</span></code>. What we call plain components here are either:</p>
<ul>
<li><p>classes that extend <a class="reference external" href="https://reactjs.org/docs/react-component.html"><code class="docutils literal notranslate"><span class="pre">Component</span></code></a></p>
<div class="highlight-jsx notranslate"><div class="highlight"><pre><span></span>class Application extends React.Component {
  render() {
    return &lt;div&gt;{this.props.content}&lt;/div&gt;;
  }
}
</pre></div>
</div>
</li>
<li><p>normal functions that take some <code class="docutils literal notranslate"><span class="pre">props</span></code> as parameter and return some JSX. We
call these functions either Stateless Components or Functional Components.
This is important to understand that these Stateless Components are <em>not</em>
especially optimized in React.</p>
<div class="highlight-jsx notranslate"><div class="highlight"><pre><span></span>function Application(props) {
  return &lt;div&gt;{props.content}&lt;/div&gt;;
}
</pre></div>
</div>
<p>These functions are equivalent to classes extending <code class="docutils literal notranslate"><span class="pre">Component</span></code>. In
the rest of the article we’ll especially focus on the latter. Unless otherwise
stated everything about classes extending <code class="docutils literal notranslate"><span class="pre">Component</span></code> is also true for
Stateless/Functional Components.</p>
</li>
</ul>
<div class="section" id="notes-on-the-use-of-jsx">
<h4>Notes on the use of JSX<a class="headerlink" href="#notes-on-the-use-of-jsx" title="Permalink to this headline">¶</a></h4>
<p>Because we don’t use a build step in mozilla-central yet, some of our
tools don’t use JSX and use <a class="reference external" href="https://reactjs.org/docs/react-api.html#createfactory">factories</a>
instead:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Application</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">dom</span><span class="p">.</span><span class="nx">div</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">content</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We’ll use JSX in this documentation for more clarity but this is strictly
equivalent. You can read more on <a class="reference external" href="https://reactjs.org/docs/react-without-jsx.html">React documentation</a>.</p>
</div>
</div>
<div class="section" id="the-first-render">
<h3>The first render<a class="headerlink" href="#the-first-render" title="Permalink to this headline">¶</a></h3>
<p>There’s only one way to start a React application and trigger a first render:
calling <code class="docutils literal notranslate"><span class="pre">ReactDOM.render</span></code>:</p>
<div class="highlight-jsx notranslate"><div class="highlight"><pre><span></span>ReactDOM.render(
  &lt;Application content=&#39;Hello World!&#39;/&gt;,
  document.getElementById(&#39;root&#39;)
);
</pre></div>
</div>
<p>React will call that component’s <code class="docutils literal notranslate"><span class="pre">render</span></code> method, and then recursively call
every child’s <code class="docutils literal notranslate"><span class="pre">render</span></code> method, generating a rendering tree and then a virtual
DOM tree. It will then render actual DOM elements to the specified container.</p>
</div>
<div class="section" id="subsequent-rerenders">
<h3>Subsequent rerenders<a class="headerlink" href="#subsequent-rerenders" title="Permalink to this headline">¶</a></h3>
<p>There are several ways to trigger a rerender:</p>
<ol class="simple">
<li><p>We call <code class="docutils literal notranslate"><span class="pre">ReactDOM.render</span></code> again with the same component.</p></li>
</ol>
<div class="highlight-jsx notranslate"><div class="highlight"><pre><span></span>ReactDOM.render(
  &lt;Application content=&#39;Good Bye, Cruel World!&#39;/&gt;,
  document.getElementById(&#39;root&#39;)
);
</pre></div>
</div>
<ol class="simple">
<li><p>One component’s state changes, through the use of <a class="reference external" href="https://reactjs.org/docs/react-component.html#setstate"><code class="docutils literal notranslate"><span class="pre">setState</span></code></a>.
If the application is using Redux, this is how Redux-connected components
trigger updates too.</p></li>
<li><p>One component’s props change. But note that this can’t happen by itself, this
is always a consequence of the case 1 or 2 in one of its parents. So we’ll
ignore this case for this chapter.</p></li>
</ol>
<p>When one of these happens, just like the initial render, React will call that
component’s <code class="docutils literal notranslate"><span class="pre">render</span></code> method, and then recursively call every child’s <code class="docutils literal notranslate"><span class="pre">render</span></code>
method, but this time possibly with changed props compared to the previous render.</p>
<p>These recursive calls produce a new rendering tree. That’s where React uses an
algorithm called <em>virtual diffing</em> or
<a class="reference external" href="https://reactjs.org/docs/reconciliation.html"><em>reconciliation</em></a> to find the
minimal set of updates to apply to the DOM. This is good because the less
updates to the DOM the less work the browser has to do to reflow and repaint the
application.</p>
</div>
<div class="section" id="main-sources-of-performance-issues">
<h3>Main sources of performance issues<a class="headerlink" href="#main-sources-of-performance-issues" title="Permalink to this headline">¶</a></h3>
<p>From this explanation we can gather that the main performance issues can
come from:</p>
<ol class="simple">
<li><p>triggering the render process <strong>too frequently</strong>,</p></li>
<li><p><strong>expensive</strong> render methods,</p></li>
<li><p>the reconciliation algorithm itself. The algorithm is O(n) according to React
authors, which means the processing duration increases linearly with <strong>the number
of elements in the tree</strong> we compare. So a larger tree means a longer time to
process.</p></li>
</ol>
<p>Let’s dive more into each one of these issues.</p>
<div class="section" id="do-not-render-too-often">
<h4>Do not render too often<a class="headerlink" href="#do-not-render-too-often" title="Permalink to this headline">¶</a></h4>
<p>A rerender will happen after calling <code class="docutils literal notranslate"><span class="pre">setState</span></code> to change the
local state.</p>
<p>Everything that’s in the state should be used in <code class="docutils literal notranslate"><span class="pre">render</span></code>.
Anything in the state that’s not used in <code class="docutils literal notranslate"><span class="pre">render</span></code> shouldn’t be in the state, but
rather in an instance variable. This way you won’t trigger an update if you
change some internal state that you don’t want to reflect in the UI.</p>
<p>If you call <code class="docutils literal notranslate"><span class="pre">setState</span></code> from an event handler you may call it too often.
This is usually not a problem because React is smart enough to merge close
setState calls and trigger a rerender only once per frame. Yet if your <code class="docutils literal notranslate"><span class="pre">render</span></code>
is expensive (see below as well) this could lead to problems and you may want to
use <code class="docutils literal notranslate"><span class="pre">setTimeout</span></code> or other similar techniques to throttle the renders.</p>
</div>
<div class="section" id="keep-render-methods-as-lean-as-possible">
<h4>Keep <code class="docutils literal notranslate"><span class="pre">render</span></code> methods as lean as possible<a class="headerlink" href="#keep-render-methods-as-lean-as-possible" title="Permalink to this headline">¶</a></h4>
<p>When rendering a list, it’s very common that we’ll map this list to a list of
components. This can be costly and we might want to cut this list in several
chunks of items or to
<a class="reference external" href="https://reactjs.org/docs/optimizing-performance.html#virtualize-long-lists">virtualize this list</a>.
Although this is not always possible or easy.</p>
<p>Do not do heavy computations in your <code class="docutils literal notranslate"><span class="pre">render</span></code> methods. Rather do them before
setting the state, and set the state to the result of these computations.
Ideally <code class="docutils literal notranslate"><span class="pre">render</span></code> should be a direct mirror of the component’s props and state.</p>
<p>Note that this rule also applies to the other methods called as part of the
rendering process: <code class="docutils literal notranslate"><span class="pre">componentWillUpdate</span></code> and <code class="docutils literal notranslate"><span class="pre">componentDidUpdate</span></code>. In
<code class="docutils literal notranslate"><span class="pre">componentDidUpdate</span></code> especially avoid synchronous reflows by getting DOM
measurements, and do not call <code class="docutils literal notranslate"><span class="pre">setState</span></code> as this would trigger yet another
update.</p>
</div>
<div class="section" id="help-the-reconciliation-algorithm-be-efficient">
<h4>Help the reconciliation algorithm be efficient<a class="headerlink" href="#help-the-reconciliation-algorithm-be-efficient" title="Permalink to this headline">¶</a></h4>
<p>The smaller the tree is, the faster the algorithm is. So it’s
useful to limit the changes to a subtree of the full tree. Note that the use of
<code class="docutils literal notranslate"><span class="pre">shouldComponentUpdate</span></code> or <code class="docutils literal notranslate"><span class="pre">PureComponent</span></code> alleviates this issue by cutting off
entire branches from the rendering tree, <a class="reference external" href="shouldcomponentupdate-and-purecomponent-avoiding-renders-altogether">we discuss this in more details
below</a>.</p>
<p>Try to change the state as close as possible to where your UI
should change (close in the components tree).</p>
<p>Do not forget to <a class="reference external" href="https://reactjs.org/docs/lists-and-keys.html">set <code class="docutils literal notranslate"><span class="pre">key</span></code> attributes when rendering a list of
things</a>, which shouldn’t be the
array’s indices but something that identifies the item in a predictable, unique
and stable way. This helps the algorithm
a lot by skipping parts that likely haven’t changed.</p>
</div>
</div>
<div class="section" id="more-documentation">
<h3>More documentation<a class="headerlink" href="#more-documentation" title="Permalink to this headline">¶</a></h3>
<p>The React documentation has <a class="reference external" href="https://reactjs.org/docs/implementation-notes.html#mounting-as-a-recursive-process">a very well documented page</a>
explaining the whole render and rerender process.</p>
</div>
</div>
<div class="section" id="shouldcomponentupdate-and-purecomponent-avoiding-renders-altogether">
<h2><code class="docutils literal notranslate"><span class="pre">shouldComponentUpdate</span></code> and <code class="docutils literal notranslate"><span class="pre">PureComponent</span></code>: avoiding renders altogether<a class="headerlink" href="#shouldcomponentupdate-and-purecomponent-avoiding-renders-altogether" title="Permalink to this headline">¶</a></h2>
<p>React has an optimized algorithm to apply changes. But the fastest algorithm is
an algorithm that isn’t executed at all.</p>
<p><a class="reference external" href="https://reactjs.org/docs/optimizing-performance.html#shouldcomponentupdate-in-action">React’s own documentation about performance</a>
is quite complete on this subject.</p>
<div class="section" id="avoiding-rerenders-with-shouldcomponentupdate">
<h3>Avoiding rerenders with <code class="docutils literal notranslate"><span class="pre">shouldComponentUpdate</span></code><a class="headerlink" href="#avoiding-rerenders-with-shouldcomponentupdate" title="Permalink to this headline">¶</a></h3>
<p>As the first step of a rerender process, React calls your component’s
<a class="reference external" href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate"><code class="docutils literal notranslate"><span class="pre">shouldComponentUpdate</span></code></a>
method with 2 parameters: the new props, and the new
state. If this method returns false, then React will skip the render process for this
component, <strong>and its whole subtree</strong>.</p>
<div class="highlight-jsx notranslate"><div class="highlight"><pre><span></span>class ComplexPanel extends React.Component {
  // Note: this syntax, new but supported by Babel, automatically binds the
  // method with the object instance.
  onClick = () =&gt; {
    this.setState({ detailsOpen: true });
  }

  // Return false to avoid a render
  shouldComponentUpdate(nextProps, nextState) {
    // Note: this works only if `summary` and `content` are primitive data
    // (eg: string, number) or immutable data
    // (keep reading to know more about this)
    return nextProps.summary !== this.props.summary
      || nextProps.content !== this.props.content
      || nextState.detailsOpen !== this.state.detailsOpen;
  }

  render() {
    return (
      &lt;div&gt;
        &lt;ComplexSummary summary={this.props.summary} onClick={this.onClick}/&gt;
        {this.state.detailsOpen
          ? &lt;ComplexContent content={this.props.content} /&gt;
          : null}
      &lt;/div&gt;
    );
  }
}
</pre></div>
</div>
<p><strong>This is a very efficient way to improve your application speed</strong>, because this
avoids everything: both calling render methods for this component <em>and</em> the
whole subtree, and the reconciliation phase for this subtree.</p>
<p>Note that just like the <code class="docutils literal notranslate"><span class="pre">render</span></code> method, <code class="docutils literal notranslate"><span class="pre">shouldComponentUpdate</span></code> is called once
per render cycle, so it needs to be very lean and return as fast as possible. So
it should execute some cheap comparisons only.</p>
</div>
<div class="section" id="purecomponent-and-immutability">
<h3><code class="docutils literal notranslate"><span class="pre">PureComponent</span></code> and immutability<a class="headerlink" href="#purecomponent-and-immutability" title="Permalink to this headline">¶</a></h3>
<p>A very common implementation of <code class="docutils literal notranslate"><span class="pre">shouldComponentUpdate</span></code> is provided by React’s
<a class="reference external" href="https://reactjs.org/docs/react-api.html#reactpurecomponent"><code class="docutils literal notranslate"><span class="pre">PureComponent</span></code></a>:
it will shallowly check the new props and states for reference equality.</p>
<div class="highlight-jsx notranslate"><div class="highlight"><pre><span></span>class ComplexPanel extends React.PureComponent {
  // Note: this syntax, new but supported by Babel, automatically binds the
  // method with the object instance.
  onClick = () =&gt; {
    // Running this repeatidly won&#39;t render more than once.
    this.setState({ detailsOpen: true });
  }

  render() {
    return (
      &lt;div&gt;
        &lt;ComplexSummary summary={this.props.summary} onClick={this.onClick}/&gt;
        {this.state.detailsOpen
          ? &lt;ComplexContent content={this.props.content} /&gt;
          : null}
      &lt;/div&gt;
    );
  }
}
</pre></div>
</div>
<p>This has a very important consequence: for non-primitive props and states, that is
objects and arrays that can be mutated without changing the reference itself,
PureComponent’s inherited <code class="docutils literal notranslate"><span class="pre">shouldComponentUpdate</span></code> will yield wrong results and will
skip renders where it shouldn’t.</p>
<p>So you’re left with one of these two options:</p>
<ul class="simple">
<li><p>either implement your own <code class="docutils literal notranslate"><span class="pre">shouldComponentUpdate</span></code> in a <code class="docutils literal notranslate"><span class="pre">Component</span></code></p></li>
<li><p>or (<strong>preferred</strong>) decide to make all your data structure immutable.</p></li>
</ul>
<p>The latter is recommended because:</p>
<ul class="simple">
<li><p>It’s much simpler to think about.</p></li>
<li><p>It’s much faster to check for equality in <code class="docutils literal notranslate"><span class="pre">shouldComponentUpdate</span></code> and in other
places (like Redux’ selectors).</p></li>
</ul>
<p>Note you could technically implement your own <code class="docutils literal notranslate"><span class="pre">shouldComponentUpdate</span></code> in a
<code class="docutils literal notranslate"><span class="pre">PureComponent</span></code> but this is quite useless because <code class="docutils literal notranslate"><span class="pre">PureComponent</span></code> is nothing
more than <code class="docutils literal notranslate"><span class="pre">Component</span></code> with a default implementation for <code class="docutils literal notranslate"><span class="pre">shouldComponentUpdate</span></code>.</p>
</div>
<div class="section" id="about-immutability">
<h3>About immutability<a class="headerlink" href="#about-immutability" title="Permalink to this headline">¶</a></h3>
<div class="section" id="what-it-doesn-t-mean">
<h4>What it doesn’t mean<a class="headerlink" href="#what-it-doesn-t-mean" title="Permalink to this headline">¶</a></h4>
<p>It doesn’t mean you need to enforce the immutability using a library like
<a class="reference external" href="https://github.com/facebook/immutable-js">Immutable</a>.</p>
</div>
<div class="section" id="what-it-means">
<h4>What it means<a class="headerlink" href="#what-it-means" title="Permalink to this headline">¶</a></h4>
<p>It means that once a structure exists, you don’t mutate it.</p>
<p><strong>Every time some data changes, the object reference must change as well</strong>. This
means a new object or a new array needs to be created. This gives the nice
reverse guarantee: if the object reference has changed, the data has changed.</p>
<p>It’s good to go one step further to get a <strong>strict equivalence</strong>: if the data
doesn’t change, the object reference mustn’t change. This isn’t necessary for
your app to work, but this is a lot better for performance as this avoids
spurious rerenders.</p>
<p>Keep reading to learn how to proceed.</p>
</div>
<div class="section" id="keep-your-state-objects-simple">
<h4>Keep your state objects simple<a class="headerlink" href="#keep-your-state-objects-simple" title="Permalink to this headline">¶</a></h4>
<p>Updating your immutable state objects can be difficult if the objects used are
complex. That’s why it’s a good idea to keep the objects simple, especially keep
them not nested, so that you don’t need to use a library like
<a class="reference external" href="https://github.com/kolodny/immutability-helper">immutability-helper</a>,
<a class="reference external" href="https://github.com/substantial/updeep">updeep</a>, or even
<a class="reference external" href="https://github.com/facebook/immutable-js">Immutable</a>. Be especially careful
with Immutable as it’s easy to create performance problems by misusing
its API.</p>
<p>If you’re using Redux (<a class="reference external" href="#a-few-words-about-redux">see below as well</a>) this
advice applies to your individual reducers as well, even if Redux tools make
it easy to have a nested/combined state.</p>
</div>
<div class="section" id="how-to-update-an-object">
<h4>How to update an object<a class="headerlink" href="#how-to-update-an-object" title="Permalink to this headline">¶</a></h4>
<p>Updating an object is quite easy.</p>
<p>You must not change/add/delete inner properties directly:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="c1">// Note that in the following examples we use the callback version</span>
<span class="c1">// of `setState` everywhere, because we build the new state from</span>
<span class="c1">// the current state.</span>

<span class="c1">// Please don&#39;t do this as this will likely induce bugs.</span>
<span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(</span><span class="nx">state</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">state</span><span class="p">.</span><span class="nx">stateObject</span><span class="p">.</span><span class="nx">details</span> <span class="o">=</span> <span class="nx">details</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">state</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// This is wrong too: `stateObject` is still mutated.</span>
<span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(({</span> <span class="nx">stateObject</span> <span class="p">})</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">stateObject</span><span class="p">.</span><span class="nx">details</span> <span class="o">=</span> <span class="nx">details</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">{</span> <span class="nx">stateObject</span> <span class="p">};</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Instead <strong>you must create a new object</strong> for this property. In this example
we’ll use the object spread operator, already implemented in Firefox, Chrome and Babel.</p>
<p>However here we take care to return the same object if it doesn’t need an update. The
comparison happens inside the callback because it depends on the state as
well. This is a good thing to do so that the shallow equality check doesn’t
return false if nothing changes.</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="c1">// Updating one property in the state</span>
<span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(({</span> <span class="nx">stateObject</span> <span class="p">})</span> <span class="p">=&gt;</span> <span class="p">({</span>
  <span class="nx">stateObject</span><span class="o">:</span> <span class="nx">stateObject</span><span class="p">.</span><span class="nx">content</span> <span class="o">===</span> <span class="nx">newContent</span>
    <span class="o">?</span> <span class="nx">stateObject</span>
    <span class="o">:</span> <span class="p">{</span> <span class="p">...</span><span class="nx">stateObject</span><span class="p">,</span> <span class="nx">content</span><span class="o">:</span> <span class="nx">newContent</span> <span class="p">},</span>
<span class="p">});</span>

<span class="c1">// This is very similar if 2 properties need an update:</span>
<span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(({</span> <span class="nx">stateObject1</span><span class="p">,</span> <span class="nx">stateObject2</span> <span class="p">})</span> <span class="p">=&gt;</span> <span class="p">({</span>
  <span class="nx">stateObject1</span><span class="o">:</span> <span class="nx">stateObject1</span><span class="p">.</span><span class="nx">content</span> <span class="o">===</span> <span class="nx">newContent</span>
    <span class="o">?</span> <span class="nx">stateObject1</span>
    <span class="o">:</span> <span class="p">{</span> <span class="p">...</span><span class="nx">stateObject1</span><span class="p">,</span> <span class="nx">content</span><span class="o">:</span> <span class="nx">newContent</span> <span class="p">},</span>
  <span class="nx">stateObject2</span><span class="o">:</span> <span class="nx">stateObject2</span><span class="p">.</span><span class="nx">details</span> <span class="o">===</span> <span class="nx">newDetails</span>
    <span class="o">?</span> <span class="nx">stateObject2</span>
    <span class="o">:</span> <span class="p">{</span> <span class="p">...</span><span class="nx">stateObject2</span><span class="p">,</span> <span class="nx">details</span><span class="o">:</span> <span class="nx">newDetails</span> <span class="p">},</span>
<span class="p">});</span>

<span class="c1">// Or if one of the properties needs to update 2 of it&#39;s own properties:</span>
<span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(({</span> <span class="nx">stateObject</span> <span class="p">})</span> <span class="p">=&gt;</span> <span class="p">({</span>
  <span class="nx">stateObject</span><span class="o">:</span> <span class="nx">stateObject</span><span class="p">.</span><span class="nx">content</span> <span class="o">===</span> <span class="nx">newContent</span> <span class="o">&amp;&amp;</span> <span class="nx">stateObject</span><span class="p">.</span><span class="nx">details</span> <span class="o">===</span> <span class="nx">newDetails</span>
    <span class="o">?</span> <span class="nx">stateObject</span>
    <span class="o">:</span> <span class="p">{</span> <span class="p">...</span><span class="nx">stateObject</span><span class="p">,</span> <span class="nx">content</span><span class="o">:</span> <span class="nx">newContent</span><span class="p">,</span> <span class="nx">details</span><span class="o">:</span> <span class="nx">newDetails</span> <span class="p">},</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Note that this isn’t about the returned <code class="docutils literal notranslate"><span class="pre">state</span></code> object, but its properties.
The returned object is always merged into the current state, and React creates
a new component’s state object at each update cycle.</p>
</div>
<div class="section" id="how-to-update-an-array">
<h4>How to update an array<a class="headerlink" href="#how-to-update-an-array" title="Permalink to this headline">¶</a></h4>
<p>Updating an array is easy too.</p>
<p>You must avoid methods that mutate the array like push/splice/pop/shift and you
must not change directly an item.</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="c1">// Please don&#39;t do this as this will likely induce bugs.</span>
<span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(({</span> <span class="nx">stateArray</span> <span class="p">})</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">stateArray</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">newItem</span><span class="p">);</span> <span class="c1">// This is wrong</span>
  <span class="nx">stateArray</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">newItem</span><span class="p">;</span> <span class="c1">// This is wrong too</span>
  <span class="k">return</span> <span class="p">{</span> <span class="nx">stateArray</span> <span class="p">};</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Instead here again you need to <strong>create a new array instance</strong>.</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="c1">// Adding an element is easy.</span>
<span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(({</span> <span class="nx">stateArray</span> <span class="p">})</span> <span class="p">=&gt;</span> <span class="p">({</span>
  <span class="nx">stateArray</span><span class="o">:</span> <span class="p">[...</span><span class="nx">stateArray</span><span class="p">,</span> <span class="nx">newElement</span><span class="p">],</span>
<span class="p">}));</span>

<span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(({</span> <span class="nx">stateArray</span> <span class="p">})</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="c1">// Removing an element is more involved.</span>
  <span class="kr">const</span> <span class="nx">newArray</span> <span class="o">=</span> <span class="nx">stateArray</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">element</span> <span class="p">=&gt;</span> <span class="nx">element</span> <span class="o">!==</span> <span class="nx">removeElement</span><span class="p">);</span>
  <span class="c1">// or</span>
  <span class="kr">const</span> <span class="nx">newArray</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">stateArray</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="nx">index</span><span class="p">),</span> <span class="p">...</span><span class="nx">stateArray</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">index</span> <span class="o">+</span> <span class="mf">1</span><span class="p">)];</span>
  <span class="c1">// or do what you want on a new clone:</span>
  <span class="kr">const</span> <span class="nx">newArray</span> <span class="o">=</span> <span class="nx">stateArray</span><span class="p">.</span><span class="nx">slice</span><span class="p">();</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="c1">// Because we want to keep the old array if removeElement isn&#39;t in the</span>
    <span class="c1">// filtered array, we compare the lengths.</span>
    <span class="c1">// We still start a render phase because we call `setState`, but thanks to</span>
    <span class="c1">// PureComponent&#39;s shouldComponentUpdate implementation we won&#39;t actually render.</span>
    <span class="nx">stateArray</span><span class="o">:</span> <span class="nx">newArray</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="nx">stateArray</span><span class="p">.</span><span class="nx">length</span> <span class="o">?</span> <span class="nx">stateArray</span> <span class="o">:</span> <span class="nx">newArray</span><span class="p">,</span>
  <span class="p">};</span>

  <span class="c1">// You can also return a falsy value to avoid the render cycle at all:</span>
  <span class="k">return</span> <span class="nx">newArray</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="nx">stateArray</span><span class="p">.</span><span class="nx">length</span>
    <span class="o">?</span> <span class="kc">null</span>
    <span class="o">:</span> <span class="p">{</span> <span class="nx">stateArray</span><span class="o">:</span> <span class="nx">newArray</span> <span class="p">};</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="how-to-update-maps-and-sets">
<h4>How to update Maps and Sets<a class="headerlink" href="#how-to-update-maps-and-sets" title="Permalink to this headline">¶</a></h4>
<p>The process is very similar for Maps and Sets. Here is a quick example:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="c1">// For a Set</span>
<span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(({</span> <span class="nx">stateSet</span> <span class="p">})</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">stateSet</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">stateSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">stateSet</span><span class="p">);</span>
    <span class="nx">stateSet</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">{</span> <span class="nx">stateSet</span> <span class="p">};</span>
<span class="p">});</span>

<span class="c1">// For a Map</span>
<span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(({</span> <span class="nx">stateMap</span> <span class="p">})</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">stateMap</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="o">!==</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">stateMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">(</span><span class="nx">stateMap</span><span class="p">);</span>
    <span class="nx">stateMap</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">{</span> <span class="nx">stateMap</span> <span class="p">};</span>
<span class="p">}));</span>
</pre></div>
</div>
</div>
<div class="section" id="how-to-update-primitive-values">
<h4>How to update primitive values<a class="headerlink" href="#how-to-update-primitive-values" title="Permalink to this headline">¶</a></h4>
<p>Obviously, with primitive types like boolean, number or string, that are
comparable with the operator <code class="docutils literal notranslate"><span class="pre">===</span></code>, it’s much easier:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
  <span class="nx">stateString</span><span class="o">:</span> <span class="s2">&quot;new string&quot;</span><span class="p">,</span>
  <span class="nx">stateNumber</span><span class="o">:</span> <span class="mf">42</span><span class="p">,</span>
  <span class="nx">stateBool</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Note that we don’t use the callback version of <code class="docutils literal notranslate"><span class="pre">setState</span></code> here. That’s because
for primitive values we don’t need to use the previous state to generate a new
state.</p>
</div>
<div class="section" id="a-few-words-about-redux">
<h4>A few words about Redux<a class="headerlink" href="#a-few-words-about-redux" title="Permalink to this headline">¶</a></h4>
<p>When working with Redux, the rules stay the same, except all of this
happens in your reducers instead of in your components. With Redux comes the
function <a class="reference external" href="https://redux.js.org/docs/api/combineReducers.html"><code class="docutils literal notranslate"><span class="pre">combineReducers</span></code></a>
that obeys all the rules we outlined before while making it possible to have a
nested state.</p>
</div>
</div>
<div class="section" id="shouldcomponentupdate-or-purecomponent">
<h3><code class="docutils literal notranslate"><span class="pre">shouldComponentUpdate</span></code> or <code class="docutils literal notranslate"><span class="pre">PureComponent</span></code>?<a class="headerlink" href="#shouldcomponentupdate-or-purecomponent" title="Permalink to this headline">¶</a></h3>
<p>It is highly recommended to go the full <strong>PureComponent + immutability</strong> route,
instead of writing custom <code class="docutils literal notranslate"><span class="pre">shouldComponentUpdate</span></code> implementations for
components. This is more generic, more maintainable, less error-prone, faster.</p>
<p>Of course all rules have exceptions and you’re free to implement a
<code class="docutils literal notranslate"><span class="pre">shouldComponentUpdate</span></code> method if you have specific cases to take care of.</p>
</div>
<div class="section" id="some-gotchas-with-purecomponent">
<h3>Some gotchas with <code class="docutils literal notranslate"><span class="pre">PureComponent</span></code><a class="headerlink" href="#some-gotchas-with-purecomponent" title="Permalink to this headline">¶</a></h3>
<p>Because <code class="docutils literal notranslate"><span class="pre">PureComponent</span></code> shallowly checks props and state, you need to take care
to not create a new reference for something that’s otherwise identical. Some
common cases are:</p>
<ul>
<li><p>Using a new instance for a prop at each render cycle. Especially, do not use
a bound function or an anonymous function (both classic functions or
arrow functions) as a prop:</p>
<div class="highlight-jsx notranslate"><div class="highlight"><pre><span></span>render() {
  return &lt;MyComponent onUpdate={() =&gt; this.update()} /&gt;;
}
</pre></div>
</div>
<p>Each time the <code class="docutils literal notranslate"><span class="pre">render</span></code> method runs, a new function will be created, and in
<code class="docutils literal notranslate"><span class="pre">MyComponent</span></code>’s <code class="docutils literal notranslate"><span class="pre">shouldComponentUpdate</span></code> the shallow check will always fail
defeating its purpose.</p>
</li>
<li><p>Using another reference for the same data. One very common example is the empty
array: if you use a new <code class="docutils literal notranslate"><span class="pre">[]</span></code> for each render, you won’t skip render. A solution
is to reuse a common instance. Be careful as this can very well be hidden
within some complicated Redux reducers.</p></li>
<li><p>A similar issue can arise if you use sets or maps. If you add an element in a
<code class="docutils literal notranslate"><span class="pre">Set</span></code> that’s already in there, you don’t need to return a new <code class="docutils literal notranslate"><span class="pre">Set</span></code> as it will be
identical.</p></li>
<li><p>Be careful with array’s methods, especially <code class="docutils literal notranslate"><span class="pre">map</span></code> or <code class="docutils literal notranslate"><span class="pre">filter</span></code>, as they always
return a new array. So even with the same inputs (same input array, same
function), you’ll get a new output, even if it contains the same data. If
you’re using Redux, <a class="reference external" href="https://github.com/reactjs/reselect">reselect</a> is
recommended.
<a class="reference external" href="https://github.com/memoize-immutable/memoize-immutable">memoize-immutable</a>
can be useful in some cases too.</p></li>
</ul>
</div>
</div>
<div class="section" id="diagnosing-performance-issues-with-some-tooling">
<h2>Diagnosing performance issues with some tooling<a class="headerlink" href="#diagnosing-performance-issues-with-some-tooling" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="./performance.md#diagnosing-performance-issues-in-react-based-applications">You can read about it in the dedicated
page</a>.</p>
</div>
<div class="section" id="breaking-the-rules-always-measure-first">
<h2>Breaking the rules: always measure first<a class="headerlink" href="#breaking-the-rules-always-measure-first" title="Permalink to this headline">¶</a></h2>
<p>You should generally follow these rules because they bring a consistent
performance in most cases.</p>
<p>However you may have specific cases that will need that you break the rules. In
that case the first thing to do is to <strong>measure</strong> using a profiler so that you
know where your problem are.</p>
<p>Then and only then you can decide to break the rules by using some mutable state
and/or custom <code class="docutils literal notranslate"><span class="pre">shouldComponentUpdate</span></code> implementation.</p>
<p>And remember to measure again after you did your changes, to check and prove
that your changes actually made an impact. Ideally you should always give links
to profiles when requesting a review for a performance patch.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../tests/README.html" class="btn btn-neutral float-right" title="Automated tests" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="performance.html" class="btn btn-neutral float-left" title="Writing efficient code" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>