

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Advanced Layers &mdash; Firefox Source Docs  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../_static/custom_theme.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../_static/firefox.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.4.4/mermaid.min.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Silk Overview" href="Silk.html" />
    <link rel="prev" title="Asynchronous Panning and Zooming" href="AsyncPanZoom.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> Firefox Source Docs
          

          
            
            <img src="../_static/firefox-wordmark.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../setup/index.html">Getting Set Up To Work On The Firefox Codebase</a></li>
</ul>
<p class="caption"><span class="caption-text">Working On Firefox</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">Working on Firefox</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bug-mgmt/index.html">Bug Handling</a></li>
</ul>
<p class="caption"><span class="caption-text">Source Code Documentation</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../browser/index.html">Firefox</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dom/index.html">DOM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../layout/index.html">Layout &amp; CSS</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Graphics</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="GraphicsOverview.html">Graphics Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="LayersHistory.html">Layers History</a></li>
<li class="toctree-l2"><a class="reference internal" href="OffMainThreadPainting.html">Off Main Thread Painting</a></li>
<li class="toctree-l2"><a class="reference internal" href="AsyncPanZoom.html">Asynchronous Panning and Zooming</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Advanced Layers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#layermanagermlgpu">LayerManagerMLGPU</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rendering-overview">Rendering Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#shaders-overview">Shaders Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cpu-occlusion-culling">CPU Occlusion Culling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#z-buffering-and-occlusion">Z-Buffering and Occlusion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#clipping">Clipping</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plane-splitting">Plane Splitting</a></li>
<li class="toctree-l3"><a class="reference internal" href="#masks">Masks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bigimage-support">BigImage Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#texture-locking">Texture Locking</a></li>
<li class="toctree-l3"><a class="reference internal" href="#buffer-measurements">Buffer Measurements</a></li>
<li class="toctree-l3"><a class="reference internal" href="#buffer-types">Buffer Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unsupported-features">Unsupported Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="#future-work">Future Work</a></li>
<li class="toctree-l3"><a class="reference internal" href="#history">History</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Silk.html">Silk Overview</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../devtools/index.html">Firefox DevTools Contributor Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../toolkit/index.html">Toolkit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../js/index.html">SpiderMonkey</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mobile/android/geckoview/index.html">Welcome to GeckoView’s documentation!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dom/bindings/webidl/index.html">WebIDL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/libpref/index.html">libpref</a></li>
<li class="toctree-l1"><a class="reference internal" href="../remote/index.html">Remote Protocol</a></li>
<li class="toctree-l1"><a class="reference internal" href="../services/common/services/index.html">Services</a></li>
<li class="toctree-l1"><a class="reference internal" href="../uriloader/index.html">File Handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../widget/cocoa/index.html">Firefox on macOS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code-quality/index.html">Code quality</a></li>
<li class="toctree-l1"><a class="reference internal" href="../writing-rust-code/index.html">Writing Rust Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/profiler/index.html">Gecko Profiler</a></li>
</ul>
<p class="caption"><span class="caption-text">The Firefox Build System</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../mach/index.html">Mach</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/try/index.html">Try Server</a></li>
<li class="toctree-l1"><a class="reference internal" href="../build/buildsystem/index.html">Build System</a></li>
<li class="toctree-l1"><a class="reference internal" href="../taskcluster/index.html">TaskCluster Task-Graph Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/moztreedocs/index.html">Managing Documentation</a></li>
</ul>
<p class="caption"><span class="caption-text">Testing &amp; Test Infrastructure</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../testing/testing-policy/index.html">Testing Policy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../testing/marionette/index.html">Marionette</a></li>
<li class="toctree-l1"><a class="reference internal" href="../testing/geckodriver/index.html">geckodriver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../web-platform/index.html">web-platform-tests documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/fuzzing/index.html">Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/sanitizer/index.html">Sanitizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../testing/perfdocs/index.html">Performance Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/code-coverage/index.html">Code coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../testing-rust-code/index.html">Testing &amp; Debugging Rust Code</a></li>
</ul>
<p class="caption"><span class="caption-text">Localization &amp; Internationalization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../intl/index.html">Internationalization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../l10n/index.html">Localization</a></li>
</ul>
<p class="caption"><span class="caption-text">Firefox and Python</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../mozbase/index.html">mozbase</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python/index.html">Using third-party Python packages</a></li>
</ul>
<p class="caption"><span class="caption-text">Metrics Collected in Firefox</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../metrics/index.html">Metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../metrics/index.html#pings">Pings</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Firefox Source Docs</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Graphics</a> &raquo;</li>
        
      <li>Advanced Layers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/gfx/AdvancedLayers.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="advanced-layers">
<h1>Advanced Layers<a class="headerlink" href="#advanced-layers" title="Permalink to this headline">¶</a></h1>
<p>Advanced Layers is a new method of compositing layers in Gecko. This
document serves as a technical overview and provides a short
walk-through of its source code.</p>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Advanced Layers attempts to group as many GPU operations as it can into
a single draw call. This is a common technique in GPU-based rendering
called “batching”. It is not always trivial, as a batching algorithm can
easily waste precious CPU resources trying to build optimal draw calls.</p>
<p>Advanced Layers reuses the existing Gecko layers system as much as
possible. Huge layer trees do not currently scale well (see the future
work section), so opportunities for batching are currently limited
without expending unnecessary resources elsewhere. However, Advanced
Layers has a few benefits:</p>
<ul class="simple">
<li><p>It submits smaller GPU workloads and buffer uploads than the existing
compositor.</p></li>
<li><p>It needs only a single pass over the layer tree.</p></li>
<li><p>It uses occlusion information more intelligently.</p></li>
<li><p>It is easier to add new specialized rendering paths and new layer
types.</p></li>
<li><p>It separates compositing logic from device logic, unlike the existing
compositor.</p></li>
<li><p>It is much faster at rendering 3d scenes or complex layer trees.</p></li>
<li><p>It has experimental code to use the z-buffer for occlusion culling.</p></li>
</ul>
<p>Because of these benefits we hope that it provides a significant
improvement over the existing compositor.</p>
<p>Advanced Layers uses the acronym “MLG” and “MLGPU” in many places. This
stands for “Mid-Level Graphics”, the idea being that it is optimized for
Direct3D 11-style rendering systems as opposed to Direct3D 12 or Vulkan.</p>
</div>
<div class="section" id="layermanagermlgpu">
<h2>LayerManagerMLGPU<a class="headerlink" href="#layermanagermlgpu" title="Permalink to this headline">¶</a></h2>
<p>Advanced layers does not change client-side rendering at all. Content
still uses Direct2D (when possible), and creates identical layer trees
as it would with a normal Direct3D 11 compositor. In fact, Advanced
Layers re-uses all of the existing texture handling and video
infrastructure as well, replacing only the composite-side layer types.</p>
<p>Advanced Layers does not create a <code class="docutils literal notranslate"><span class="pre">LayerManagerComposite</span></code> - instead,
it creates a <code class="docutils literal notranslate"><span class="pre">LayerManagerMLGPU</span></code>. This layer manager does not have a
<code class="docutils literal notranslate"><span class="pre">Compositor</span></code> - instead, it has an <code class="docutils literal notranslate"><span class="pre">MLGDevice</span></code>, which roughly
abstracts the Direct3D 11 API. (The hope is that this API is easily
interchangeable for something else when cross-platform or software
support is needed.)</p>
<p><code class="docutils literal notranslate"><span class="pre">LayerManagerMLGPU</span></code> also dispenses with the old “composite” layers for
new layer types. For example, <code class="docutils literal notranslate"><span class="pre">ColorLayerComposite</span></code> becomes
<code class="docutils literal notranslate"><span class="pre">ColorLayerMLGPU</span></code>. Since these layer types implement <code class="docutils literal notranslate"><span class="pre">HostLayer</span></code>,
they integrate with <code class="docutils literal notranslate"><span class="pre">LayerTransactionParent</span></code> as normal composite
layers would.</p>
</div>
<div class="section" id="rendering-overview">
<h2>Rendering Overview<a class="headerlink" href="#rendering-overview" title="Permalink to this headline">¶</a></h2>
<p>The steps for rendering are described in more detail below, but roughly
the process is:</p>
<ol class="arabic simple">
<li><p>Sort layers front-to-back.</p></li>
<li><p>Create a dependency tree of render targets (called “views”).</p></li>
<li><p>Accumulate draw calls for all layers in each view.</p></li>
<li><p>Upload draw call buffers to the GPU.</p></li>
<li><p>Execute draw commands for each view.</p></li>
</ol>
<p>Advanced Layers divides the layer tree into “views”
(<code class="docutils literal notranslate"><span class="pre">RenderViewMLGPU</span></code>), which correspond to a render target. The root
layer is represented by a view corresponding to the screen. Layers that
require intermediate surfaces have temporary views. Layers are analyzed
front-to-back, and rendered back-to-front within a view. Views
themselves are rendered front-to-back, to minimize render target
switching.</p>
<p>Each view contains one or more rendering passes (<code class="docutils literal notranslate"><span class="pre">RenderPassMLGPU</span></code>). A
pass represents a single draw command with one or more rendering items
attached to it. For example, a <code class="docutils literal notranslate"><span class="pre">SolidColorPass</span></code> item contains a
rectangle and an RGBA value, and many of these can be drawn with a
single GPU call.</p>
<p>When considering a layer, views will first try to find an existing
rendering batch that can support it. If so, that pass will accumulate
another draw item for the layer. Otherwise, a new pass will be added.</p>
<p>When trying to find a matching pass for a layer, there is a tradeoff in
CPU time versus the GPU time saved by not issuing another draw commands.
We generally care more about CPU time, so we do not try too hard in
matching items to an existing batch.</p>
<p>After all layers have been processed, there is a “prepare” step. This
copies all accumulated draw data and uploads it into vertex and constant
buffers in the GPU.</p>
<p>Finally, we execute rendering commands. At the end of the frame, all
batches and (most) constant buffers are thrown away.</p>
</div>
<div class="section" id="shaders-overview">
<h2>Shaders Overview<a class="headerlink" href="#shaders-overview" title="Permalink to this headline">¶</a></h2>
<p>Advanced Layers currently has five layer-related shader pipelines:</p>
<ul class="simple">
<li><p>Textured (PaintedLayer, ImageLayer, CanvasLayer)</p></li>
<li><p>ComponentAlpha (PaintedLayer with component-alpha)</p></li>
<li><p>YCbCr (ImageLayer with YCbCr video)</p></li>
<li><p>Color (ColorLayers)</p></li>
<li><p>Blend (ContainerLayers with mix-blend modes)</p></li>
</ul>
<p>There are also three special shader pipelines:</p>
<ul class="simple">
<li><p>MaskCombiner, which is used to combine mask layers into a single
texture.</p></li>
<li><p>Clear, which is used for fast region-based clears when not directly
supported by the GPU.</p></li>
<li><p>Diagnostic, which is used to display the diagnostic overlay texture.</p></li>
</ul>
<p>The layer shaders follow a unified structure. Each pipeline has a vertex
and pixel shader. The vertex shader takes a layers ID, a z-buffer depth,
a unit position in either a unit square or unit triangle, and either
rectangular or triangular geometry. Shaders can also have ancillary data
needed like texture coordinates or colors.</p>
<p>Most of the time, layers have simple rectangular clips with simple
rectilinear transforms, and pixel shaders do not need to perform masking
or clipping. For these layers we use a fast-path pipeline, using
unit-quad shaders that are able to clip geometry so the pixel shader
does not have to. This type of pipeline does not support complex masks.</p>
<p>If a layer has a complex mask, a rotation or 3d transform, or a complex
operation like blending, then we use shaders capable of handling
arbitrary geometry. Their input is a unit triangle, and these shaders
are generally more expensive.</p>
<p>All of the shader-specific data is modelled in ShaderDefinitionsMLGPU.h.</p>
</div>
<div class="section" id="cpu-occlusion-culling">
<h2>CPU Occlusion Culling<a class="headerlink" href="#cpu-occlusion-culling" title="Permalink to this headline">¶</a></h2>
<p>By default, Advanced Layers performs occlusion culling on the CPU. Since
layers are visited front-to-back, this is simply a matter of
accumulating the visible region of opaque layers, and subtracting it
from the visible region of subsequent layers. There is a major
difference between this occlusion culling and PostProcessLayers of the
old compositor: AL performs culling after invalidation, not before.
Completely valid layers will have an empty visible region.</p>
<p>Most layer types (with the exception of images) will intelligently split
their draw calls into a batch of individual rectangles, based on their
visible region.</p>
</div>
<div class="section" id="z-buffering-and-occlusion">
<h2>Z-Buffering and Occlusion<a class="headerlink" href="#z-buffering-and-occlusion" title="Permalink to this headline">¶</a></h2>
<p>Advanced Layers also supports occlusion culling on the GPU, using a
z-buffer. This is disabled by default currently since it is
significantly costly on integrated GPUs. When using the z-buffer, we
separate opaque layers into a separate list of passes. The render
process then uses the following steps:</p>
<ol class="arabic simple">
<li><p>The depth buffer is set to read-write.</p></li>
<li><p>Opaque batches are executed.,</p></li>
<li><p>The depth buffer is set to read-only.</p></li>
<li><p>Transparent batches are executed.</p></li>
</ol>
<p>The problem we have observed is that the depth buffer increases writes
to the GPU, and on integrated GPUs this is expensive - we have seen draw
call times increase by 20-30%, which is the wrong direction we want to
take on battery life. In particular on a full screen video, the call to
ClearDepthStencilView plus the actual depth buffer write of the video
can double GPU time.</p>
<p>For now the depth-buffer is disabled until we can find a compelling case
for it on non-integrated hardware.</p>
</div>
<div class="section" id="clipping">
<h2>Clipping<a class="headerlink" href="#clipping" title="Permalink to this headline">¶</a></h2>
<p>Clipping is a bit tricky in Advanced Layers. We cannot use the hardware
“scissor” feature, since the clip can change from instance to instance
within a batch. And if using the depth buffer, we cannot write
transparent pixels for the clipped area. As a result we always clip
opaque draw rects in the vertex shader (and sometimes even on the CPU,
as is needed for sane texture coordinates). Only transparent items are
clipped in the pixel shader. As a result, masked layers and layers with
non-rectangular transforms are always considered transparent, and use a
more flexible clipping pipeline.</p>
</div>
<div class="section" id="plane-splitting">
<h2>Plane Splitting<a class="headerlink" href="#plane-splitting" title="Permalink to this headline">¶</a></h2>
<p>Plane splitting is when a 3D transform causes a layer to be split - for
example, one transparent layer may intersect another on a separate
plane. When this happens, Gecko sorts layers using a BSP tree and
produces a list of triangles instead of draw rects.</p>
<p>These layers cannot use the “unit quad” shaders that support the fast
clipping pipeline. Instead they always use the full triangle-list
shaders that support extended vertices and clipping.</p>
<p>This is the slowest path we can take when building a draw call, since we
must interact with the polygon clipping and texturing code.</p>
</div>
<div class="section" id="masks">
<h2>Masks<a class="headerlink" href="#masks" title="Permalink to this headline">¶</a></h2>
<p>For each layer with a mask attached, Advanced Layers builds a
<code class="docutils literal notranslate"><span class="pre">MaskOperation</span></code>. These operations must resolve to a single mask
texture, as well as a rectangular area to which the mask applies. All
batched pixel shaders will automatically clip pixels to the mask if a
mask texture is bound. (Note that we must use separate batches if the
mask texture changes.)</p>
<p>Some layers have multiple mask textures. In this case, the MaskOperation
will store the list of masks, and right before rendering, it will invoke
a shader to combine these masks into a single texture.</p>
<p>MaskOperations are shared across layers when possible, but are not
cached across frames.</p>
</div>
<div class="section" id="bigimage-support">
<h2>BigImage Support<a class="headerlink" href="#bigimage-support" title="Permalink to this headline">¶</a></h2>
<p>ImageLayers and CanvasLayers can be tiled with many individual textures.
This happens in rare cases where the underlying buffer is too big for
the GPU. Early on this caused problems for Advanced Layers, since AL
required one texture per layer. We implemented BigImage support by
creating temporary ImageLayers for each visible tile, and throwing those
layers away at the end of the frame.</p>
<p>Advanced Layers no longer has a 1:1 layer:texture restriction, but we
retain the temporary layer solution anyway. It is not much code and it
means we do not have to split <code class="docutils literal notranslate"><span class="pre">TexturedLayerMLGPU</span></code> methods into
iterated and non-iterated versions.</p>
</div>
<div class="section" id="texture-locking">
<h2>Texture Locking<a class="headerlink" href="#texture-locking" title="Permalink to this headline">¶</a></h2>
<p>Advanced Layers has a different texture locking scheme than the existing
compositor. If a texture needs to be locked, then it is locked by the
MLGDevice automatically when bound to the current pipeline. The
MLGDevice keeps a set of the locked textures to avoid double-locking. At
the end of the frame, any textures in the locked set are unlocked.</p>
<p>We cannot easily replicate the locking scheme in the old compositor,
since the duration of using the texture is not scoped to when we visit
the layer.</p>
</div>
<div class="section" id="buffer-measurements">
<h2>Buffer Measurements<a class="headerlink" href="#buffer-measurements" title="Permalink to this headline">¶</a></h2>
<p>Advanced Layers uses constant buffers to send layer information and
extended instance data to the GPU. We do this by pre-allocating large
constant buffers and mapping them with <code class="docutils literal notranslate"><span class="pre">MAP_DISCARD</span></code> at the beginning
of the frame. Batches may allocate into this up to the maximum bindable
constant buffer size of the device (currently, 64KB).</p>
<p>There are some downsides to this approach. Constant buffers are
difficult to work with - they have specific alignment requirements, and
care must be taken not too run over the maximum number of constants in a
buffer. Another approach would be to store constants in a 2D texture and
use vertex shader texture fetches. Advanced Layers implemented this and
benchmarked it to decide which approach to use. Textures seemed to skew
better on GPU performance, but worse on CPU, but this varied depending
on the GPU. Overall constant buffers performed best and most
consistently, so we have kept them.</p>
<p>Additionally, we tested different ways of performing buffer uploads.
Buffer creation itself is costly, especially on integrated GPUs, and
especially so for immutable, immediate-upload buffers. As a result we
aggressively cache buffer objects and always allocate them as
MAP_DISCARD unless they are write-once and long-lived.</p>
</div>
<div class="section" id="buffer-types">
<h2>Buffer Types<a class="headerlink" href="#buffer-types" title="Permalink to this headline">¶</a></h2>
<p>Advanced Layers has a few different classes to help build and upload
buffers to the GPU. They are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MLGBuffer</span></code>. This is the low-level shader resource that
<code class="docutils literal notranslate"><span class="pre">MLGDevice</span></code> exposes. It is the building block for buffer helper
classes, but it can also be used to make one-off, immutable,
immediate-upload buffers. MLGBuffers, being a GPU resource, are
reference counted.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SharedBufferMLGPU</span></code>. These are large, pre-allocated buffers that
are read-only on the GPU and write-only on the CPU. They usually
exceed the maximum bindable buffer size. There are three shared
buffers created by default and they are automatically unmapped as
needed: one for vertices, one for vertex shader constants, and one
for pixel shader constants. When callers allocate into a shared
buffer they get back a mapped pointer, a GPU resource, and an offset.
When the underlying device supports offsetable buffers (like
<code class="docutils literal notranslate"><span class="pre">ID3D11DeviceContext1</span></code> does), this results in better GPU
utilization, as there are less resources and fewer upload commands.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ConstantBufferSection</span></code> and <code class="docutils literal notranslate"><span class="pre">VertexBufferSection</span></code>. These are
“views” into a <code class="docutils literal notranslate"><span class="pre">SharedBufferMLGPU</span></code>. They contain the underlying
<code class="docutils literal notranslate"><span class="pre">MLGBuffer</span></code>, and when offsetting is supported, the offset
information necessary for resource binding. Sections are not
reference counted.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">StagingBuffer</span></code>. A dynamically sized CPU buffer where items can be
appended in a free-form manner. The stride of a single “item” is
computed by the first item written, and successive items must have
the same stride. The buffer must be uploaded to the GPU manually.
Staging buffers are appropriate for creating general constant or
vertex buffer data. They can also write items in reverse, which is
how we render back-to-front when layers are visited front-to-back.
They can be uploaded to a <code class="docutils literal notranslate"><span class="pre">SharedBufferMLGPU</span></code> or an immutabler
<code class="docutils literal notranslate"><span class="pre">MLGBuffer</span></code> very easily. Staging buffers are not reference counted.</p></li>
</ul>
</div>
<div class="section" id="unsupported-features">
<h2>Unsupported Features<a class="headerlink" href="#unsupported-features" title="Permalink to this headline">¶</a></h2>
<p>Currently, these features of the old compositor are not yet implemented.</p>
<ul class="simple">
<li><p>OpenGL and software support (currently AL only works on D3D11).</p></li>
<li><p>APZ displayport overlay.</p></li>
<li><p>Diagnostic/developer overlays other than the FPS/timing overlay.</p></li>
<li><p>DEAA. It was never ported to the D3D11 compositor, but we would like
it.</p></li>
<li><p>Component alpha when used inside an opaque intermediate surface.</p></li>
<li><p>Effects prefs. Possibly not needed post-B2G removal.</p></li>
<li><p>Widget overlays and underlays used by macOS and Android.</p></li>
<li><p>DefaultClearColor. This is Android specific, but is easy to added
when needed.</p></li>
<li><p>Frame uniformity info in the profiler. Possibly not needed post-B2G
removal.</p></li>
<li><p>LayerScope. There are no plans to make this work.</p></li>
</ul>
</div>
<div class="section" id="future-work">
<h2>Future Work<a class="headerlink" href="#future-work" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Refactor for D3D12/Vulkan support (namely, split MLGDevice into
something less stateful and something else more low-level).</p></li>
<li><p>Remove “MLG” moniker and namespace everything.</p></li>
<li><p>Other backends (D3D12/Vulkan, OpenGL, Software)</p></li>
<li><p>Delete CompositorD3D11</p></li>
<li><p>Add DEAA support</p></li>
<li><p>Re-enable the depth buffer by default for fast GPUs</p></li>
<li><p>Re-enable right-sizing of inaccurately sized containers</p></li>
<li><p>Drop constant buffers for ancillary vertex data</p></li>
<li><p>Fast shader paths for simple video/painted layer cases</p></li>
</ul>
</div>
<div class="section" id="history">
<h2>History<a class="headerlink" href="#history" title="Permalink to this headline">¶</a></h2>
<p>Advanced Layers has gone through four major design iterations. The
initial version used tiling - each render view divided the screen into
128x128 tiles, and layers were assigned to tiles based on their
screen-space draw area. This approach proved not to scale well to 3d
transforms, and so tiling was eliminated.</p>
<p>We replaced it with a simple system of accumulating draw regions to each
batch, thus ensuring that items could be assigned to batches while
maintaining correct z-ordering. This second iteration also coincided
with plane-splitting support.</p>
<p>On large layer trees, accumulating the affected regions of batches
proved to be quite expensive. This led to a third iteration, using depth
buffers and separate opaque and transparent batch lists to achieve
z-ordering and occlusion culling.</p>
<p>Finally, depth buffers proved to be too expensive, and we introduced a
simple CPU-based occlusion culling pass. This iteration coincided with
using more precise draw rects and splitting pipelines into unit-quad,
cpu-clipped and triangle-list, gpu-clipped variants.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Silk.html" class="btn btn-neutral float-right" title="Silk Overview" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="AsyncPanZoom.html" class="btn btn-neutral float-left" title="Asynchronous Panning and Zooming" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>